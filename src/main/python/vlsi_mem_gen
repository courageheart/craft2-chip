#!/usr/bin/env python
import sys
import math
import re
import random
import os
import argparse
import subprocess
import operator
import copy
import pprint

# put all the possible values here
sram_dictionary = (

    # true dual-port memories:
    #{'prefix': 'tsdn16ffcll', 'vt': ('svt','lvt','ulvt'), 'mux': (4), 'depth': range(64,2049,64), 'width': range(4,73), 'seg': '', 'version': '100a', 'ports': 2},

    # single-port memories
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 2,  'depth': range(16,513,8),       'width': range(8,289,2),  'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 4,  'depth': range(32,1025,16),     'width': range(4,145),    'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 4,  'depth': range(1056,2049,32),   'width': range(8,145),    'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 4,  'depth': range(2112,4097,64),   'width': range(8,145),    'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 8,  'depth': range(64,2049,32),     'width': range(4,73),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 8,  'depth': range(2112,4097,64),   'width': range(4,73),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 8,  'depth': range(4224,8193,64),   'width': range(4,73),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 16, 'depth': range(128,4097,64),    'width': range(4,40),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 16, 'depth': range(4224,8193,128),  'width': range(4,40),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},
    {'prefix': 'ts1n16ffcll', 'prefix2': 'a', 'vt': ('svt','lvt','ulvt'), 'mux': 16, 'depth': range(8448,16385,128), 'width': range(4,40),     'seg': 's', 'version': '100a', 'ports': 1, 'dir': 'tsn16ffcllspsram_20131200_100a'},

    # ultra high-density 2-port register file, our "one read one write port" memory; have compiler for 100a but have doc for 110a, so assuming they're equivalent
    {'prefix': 'ts6n16ffpgl', 'prefix2': 'b', 'vt': ('svt','lvt','ulvt'), 'mux': 1,  'depth': range(8,257,4),        'width': range(16,289,2), 'seg': '',  'version': '100a', 'ports': 2, 'dir': 'tsn16ffclluhd2prf_20131200_100a'},
    {'prefix': 'ts6n16ffpgl', 'prefix2': 'b', 'vt': ('svt','lvt','ulvt'), 'mux': 2,  'depth': range(16,513,8),       'width': range(8,145,2),  'seg': '',  'version': '100a', 'ports': 2, 'dir': 'tsn16ffclluhd2prf_20131200_100a'},
    {'prefix': 'ts6n16ffpgl', 'prefix2': 'b', 'vt': ('svt','lvt','ulvt'), 'mux': 4,  'depth': range(32,1025,16),     'width': range(4,73),     'seg': '',  'version': '100a', 'ports': 2, 'dir': 'tsn16ffclluhd2prf_20131200_100a'},

)

def main():
  args = parse_args()
  print "\nBegin SRAM mapping..."
  subprocess.call(['rm','-f',args.outfile]) # Blow away any existing file to avoid appending to it
  mems = parse_conf(args.conf_file)
  if not args.ff_only == 'True':
    mems = gen_sram_mems(mems,args.ff_threshold,args.outfile,args.vt)
  mems = gen_ff_mems(mems,args.conf_file,args.outfile,args.ff_only)
  #gen_report(mems,srams,args.report_file)
  print "End SRAM mapping...\n"

def parse_args():
  parser = argparse.ArgumentParser(description='New vlsi mem gen!')
  parser.add_argument('-conf', dest='conf_file', required=True, help='.conf file generated by Chisel')
  parser.add_argument('-v', dest='outfile', required=True, help='Output verilog file that instantiates the memories')
  parser.add_argument('-vt', dest='vt', default='svt', help='Threshold voltage of memories: svt, lvt, or ulvt')
  parser.add_argument('-report', dest='report_file', required=True, help='Name of generated utilization report file')
  parser.add_argument('-ff', dest='ff_only', default=False, help='Build all memories with RTL flip-flops')
  parser.add_argument('-ff_threshold', dest='ff_threshold', default=512, type=int, help='Build all memories with fewer bits than this with flip-flops')
  return parser.parse_args()

def parse_conf(conf_file):
  mems = {}
  for line in open(conf_file,'r'):
    (name,width,depth,ports,masking,mask_gran) = (-1,-1,-1,-1,-1,-1)
    tokens = line.split()
    for i in xrange(0,len(tokens),2):
      s = tokens[i]
      if s == 'name': name = tokens[i+1]
      elif s == 'width': width = int(tokens[i+1])
      elif s == 'depth': depth = int(tokens[i+1])
      elif s == 'ports':
        p = tokens[i+1].split()
        if 'write,read' in p[0]: ports = 2
        elif 'rw' in p[0]: ports = 1
        if 'm' in p[0]: masking = True
        else: masking = False
      elif s == 'mask_gran': mask_gran = int(tokens[i+1])
    if (name==-1 or width==-1 or depth==-1 or ports==-1 or masking==-1): sys.exit('Error: malformed .conf file!  %s' % line)
    mems[name] = {'width':width, 'depth':depth, 'ports':ports, 'masking':masking, 'mask_gran':mask_gran}
  return mems

def gen_ff_mems(mems,conf_file,outfile,force_ff):
  tempfile = 'temp.mem'
  f = open(outfile,'a')
  if force_ff == 'True': print "Mapping all memories to FFs..."
  for name in sorted(mems.iterkeys()):
    if 'mapped' not in mems[name]:
      mems[name]['width'] = mems[name]['width'] * mems[name]['multi_w']
      mems[name]['depth'] = mems[name]['depth'] * mems[name]['multi_d']
      write_ff_verilog(name,mems[name]['width'],mems[name]['depth'],mems[name]['ports'],mems[name]['masking'],mems[name]['mask_gran'],outfile)
      mems[name]['mapped'] = 'FF'
      if force_ff != 'True':
        if mems[name]['matches'] == -1: print "%s is very small, defaulting to FFs" % name
        else: print "No match for %s, defaulting to FFs" % name
  return mems

def gen_sram_mems(mems,ff_threshold,outfile,vt):
  for mem_name in sorted(mems.iterkeys()):
    mems[mem_name]['multi_w'] = 1
    mems[mem_name]['multi_d'] = 1
    while mems[mem_name]['width'] > 256: # [stevo]: assume we want to keep large word widths
      if mems[mem_name]['width'] % 2 != 0:
        sys.exit('Error: Cannot divide large memory %s width %d evenly' % (mem_name,mems[mem_name]['width']))
      mems[mem_name]['width'] = mems[mem_name]['width']/2
      mems[mem_name]['multi_w'] = mems[mem_name]['multi_w'] * 2
    mems = find_best_match(mem_name,mems,ff_threshold,vt)
    mem = mems[mem_name]
    if 'mapped' in mem:
      write_sram_verilog(mem_name,mems,outfile)
      compile_sram(mem)
  return mems

def compile_sram(mem):
  with open("%s.txt"%(mem['mapped']), 'w') as f:
    f.write(mem['config'] + "\n")
  print "Compiling %s"%(mem['mapped'])
  print "Running command: %s\n"%(mem['cmd'])
  subprocess.call(mem['cmd'], shell=True)


def find_best_match(mem_name,mems,ff_threshold,vt):
  mem = mems[mem_name]
  mem_bits = mem['width'] * mem['depth']
  # No tiny SRAMs, just use FFs
  if mem_bits < ff_threshold: 
    mem['matches'] = -1
    return mems
  else:
    for sram in sram_dictionary:
      if sram['ports'] == mem['ports'] and mem['width'] in sram['width'] and mem['depth'] in sram['depth']:
        name = get_sram_name(sram,mem['width'],mem['depth'],vt,mem['masking']=='True')
        if 'mapped' in mem:
          print 'Found another match: %s, %s'%(mem_name,name)
          mem['matches'] = mem['matches'] + 1
        else:
          print 'Found match: %s, %s' % (mem_name,name)
          mem['mapped'] = name
          mem['cmd'] = get_sram_cmd(sram,mem['width'],mem['depth'],vt,mem['masking']=='True')
          mem['config'] = get_sram_config(sram,mem['width'],mem['depth'])
          mem['mux'] = sram['mux']
          mem['vt'] = vt
          mem['matches'] = 1
  if not 'matches' in mem and mem['depth'] > 256:
    if mem['depth'] % 2 != 0:
      sys.exit('Error: Cannot divide large memory %s depth %d evenly' % (mem_name,mem['depth']))
    mem['depth'] = mem['depth'] / 2
    mem['multi_d'] = mem['multi_d'] * 2
    find_best_match(mem_name,mems,ff_threshold,vt)
  if not 'matches' in mem:
    mem['matches'] = 0
  return mems

def get_sram_name(sram,width,depth,vt,mask):
  mask_string = 'w' if mask else ''
  return "%s%s%s%dx%dm%d%s%s_%s"%(sram['prefix'],vt,sram['prefix2'],depth,width,sram['mux'],sram['seg'],mask_string,sram['version'])

def get_sram_cmd(sram,width,depth,vt,mask):
  split = sram['dir'].split('_')
  perl = '$TSMCHOME/sram/Compiler/%s/%s_%s.pl'%(sram['dir'],split[0],split[2])
  config = '-file %s.txt'%(get_sram_name(sram,width,depth,vt,mask))
  options = '-NonBIST -NonSLP -NonDSLP -NonSD'
  if not vt == 'ulvt':
    options = options + ' -' + vt
  if not mask:
    options = options + ' -NonBWEB'
  home = "MC_HOME=$TSMCHOME/sram/Compiler/%s"%(sram['dir']) 
  return '%s %s %s %s'%(home,perl,config,options)

def get_sram_config(sram,width,depth):
  return '%dx%dm%d%s'%(depth,width,sram['mux'],sram['seg'])

  
# TODO
# write_sram_verilog does not correctly handle widths that do not divide evenly by multi_w
# For now, find_best_match refuses to map in this case.
# But there's no technical reason the mapping wouldn't work - it would just be a pain to script.

def write_sram_verilog(mem_name,mems,outfile):
  mem = mems[mem_name]
  sram_name = mem['mapped']
  mw = mem['multi_w']
  md = mem['multi_d']
  m = mw * md
  sram_addr_width = int(max(math.ceil(math.log(mem['depth'])/math.log(2)),1))
  mem_addr_width = int(max(math.ceil(math.log(mem['depth']*md)/math.log(2)),1))
  addr_diff = mem_addr_width - sram_addr_width
  if mem['ports'] == 1:
    (readportstr,writeportstr) = (m*['RW0_rdata'],'RW0_wdata')
    for i in range(0,m): readportstr[i] = 'out%d'%(i/mw)
    clocks = m*[".CLK(RW0_clk)"]
    enables = m*[".CEB(~RW0_en), .WEB(~RW0_wmode)"]
    addrs = m*[".A(RW0_addr)"]
    if md > 1:
      addrs = m*[".A(RW0_addr[%d:0])" % (sram_addr_width-1)]
      for i in range(0,m):
        readportstr[i] = 'out%d'%(i/mw)
        if addr_diff == 1:
          enmaskstr = "(RW0_addr[%d]==%d'd%d)" % (mem_addr_width-1,addr_diff,i/mw)
        else:
          enmaskstr = "(RW0_addr[%d:%d]==%d'd%d)" % (mem_addr_width-1,sram_addr_width,addr_diff,i/mw)
        enables[i] = ".CEB(~(RW0_en & %s)), .WEB(~(RW0_wmode & %s))" % (enmaskstr,enmaskstr)
    tsels = m*[".RTSEL(2'b01), .WTSEL(%s)"%(get_wtsel(mem['ports'],mem['mux'],mem['width'],mem['vt']))]
  else:
    (readportstr,writeportstr) = (m*['R0_data'],'W0_data')
    for i in range(0,m): readportstr[i] = 'out%d'%(i/mw)
    clocks = m*[".CLK(R0_clk)"] # usually R0_clk = W0_clk, but this could be bad if user expects differently as W0_clk is disconnected
    enables = m*[".REB(~R0_en), .WEB(~W0_en)"]
    addrs = m*[".AA(W0_addr), .AB(R0_addr)"]
    if md > 1:
      test = 2*((sram_addr_width-1),)
      addrs = m*[".WA(W0_addr[%d:0]), .RA(R0_addr[%d:0])" % (sram_addr_width-1,sram_addr_width-1)]
      for i in range(0,m):
        readportstr[i] = 'out%d'%(i/mw)
        if addr_diff == 1:
          writeenmaskstr = "(W0_addr[%d]==%d'd%d)" % (mem_addr_width-1,addr_diff,i/mw)
          readenmaskstr = "(R0_addr[%d]==%d'd%d)" % (mem_addr_width-1,addr_diff,i/mw)
        else:
          writeenmaskstr = "(W0_addr[%d:%d]==%d'd%d)" % (mem_addr_width-1,sram_addr_width,addr_diff,i/mw)
          readenmaskstr = "(R0_addr[%d:%d]==%d'd%d)" % (mem_addr_width-1,sram_addr_width,addr_diff,i/mw)
        enables[i] = ".REB(~(R0_en & %s)), .WEB(~(W0_en & %s)))" % (readenmaskstr,writeenmaskstr)
    tsels = m*[".RTSEL(2'b01), .WTSEL(%s), .MTSEL(%s)"%(get_wtsel(mem['ports'],mem['mux'],mem['width'],mem['vt']),get_wtsel(mem['ports'],mem['mux'],mem['width'],mem['vt']))]
  datas = []
  for i in range(0,m):
    if mw == 1:
      datas.append(".D(%s), .Q(%s)" % (writeportstr,readportstr[i]))
    end = (i%mw)*mem['width']
    start = end+mem['width']-1
    datas.append(".D(%s[%d:%d]), .Q(%s[%d:%d])"%(writeportstr,start,end,readportstr[i],start,end))
  masks = m*[""]
  if mem['masking']=='True':
    for i in range(0,m):
      if mw == 1:
        masks[i] += ".BWEB(~full_mask),"
      end = (i%mw)*mem['width']
      start = end+mem['width']-1
      masks[i] += ".BWEB(~full_mask[%d:%d])," % (start,end)
  sram_text = []
  for i in range(0,m):
    sram_text.append('')
    if i%mw == 0: sram_text[i] += '  wire [%d:0] out%d;\n\n' % (mem['width']*mw-1,i/mw)
    sram_text[i] += '  %s sram%s\n' % (sram_name,i)
    sram_text[i] += '  (\n'
    sram_text[i] += '    %s,\n' % clocks[i]
    sram_text[i] += '    %s,\n' % enables[i]
    sram_text[i] += '    %s, %s,\n' % (addrs[i],datas[i])
    sram_text[i] += '    %s\n' % masks[i]
    sram_text[i] += '    %s\n' % tsels[i]
    sram_text[i] += '  );\n'
  port_spec = gen_port_spec(mem['width']*mw,mem['depth']*md,mem['ports'],mem['masking'],mem['mask_gran']) 
  s = '// vlsi_mem_gen: name=%s, depth=%d, width=%d, ports=%d, masking=%s%s\n' % \
    (mem_name,mem['depth']*md,mem['width']*mw,mem['ports'],str(mem['masking']),', mask_gran=%d'%mem['mask_gran'] if mem['masking'] else '')
  s += "module %s\n(\n  %s\n);\n\n" % (mem_name, ',\n  '.join(port_spec))
  if mem['masking']:
    mask_expand_str = ','.join(map(lambda i:'{%d{%s[%d]}}'%(mem['mask_gran'],'W0_mask' if mem['ports']==2 else 'RW0_wmask',i), \
      reversed(range(0,mem['width']*mw/mem['mask_gran']))))
    s += '  wire [%d:0] full_mask = {%s};\n\n' % (mem['width']*mw-1,mask_expand_str)
  readportstr = ('RW0' if mem['ports'] == 1 else 'R0')
  readportDataName = readportstr + ('_rdata' if mem['ports'] == 1 else '_data')
  for i in range(0,m):
    s += "%s\n" % sram_text[i]
    # CHECK FOR Xs
    s += "  `ifndef SYNTHESIS\n"
    if(i%mw == 0):
      s += "  reg [%d:0] clean_out%d;\n"%(mem['width']*mw-1,i/mw)
    s += "  always @({0}0_addr or {0}0_en or out{1})\n".format("RW" if mem['ports'] == 1 else 'R', i/mw)
    s += "    begin\n"
    for w in range(0, mem['width']):
      s += "    if (out%d[%d] === 1'bx) begin\n"%(i/mw,i%mw*(mem['width']) + w)
      s += "      clean_out%d[%d] <= $random;\n"%(i/mw,i%mw*(mem['width']) + w)
      s += "    end else begin\n"
      s += "      clean_out%d[%d] <= out%d[%d];\n"%(i/mw,i%mw*(mem['width']) + w,i/mw,i%mw*(mem['width']) + w)
      s += "    end\n"
    s += "    end\n"
    s += "  `else\n"
    if(i%mw == 0):
      s += "  wire [%d:0] clean_out%d;\n"%(mem['width']*mw-1,i/mw)
      s += "  assign clean_out%d = out%d;\n"%(i/mw, i/mw)
    s += "  `endif\n"
  if md > 1:
    s += '  reg [%d:0] %s;\n' % (mem['width']*mw-1,readportDataName )
    if md == 2:
      s += '  reg addr_reg;\n  always @(posedge %s_clk)\n    addr_reg <= %s_addr[%d];\n\n' % (readportstr,readportstr,mem_addr_width-1)
    else:
      s += '  reg [%d:0] addr_reg;\n  always @(posedge %s_clk)\n    addr_reg <= %s_addr[%d:%d];\n\n' % \
        (addr_diff-1,readportstr,readportstr,mem_addr_width-1,sram_addr_width)
    s += '  always @*\n    case (addr_reg)\n'
    for i in range(0,md):
      s += "      %d'd%d: %s = clean_out%d;\n" % (addr_diff,i,readportDataName,i)
    s += '    endcase\n\n'
  else:
    s += '  assign %s = clean_out%d;\n'%(readportDataName, 0)
  s += "endmodule\n\n"
  f = open(outfile,'a')
  f.write(s)
  f.close()

def write_ff_verilog(name, width, depth, ports, masking, mask_gran, outfile):
  addr_width = max(math.ceil(math.log(depth)/math.log(2)),1)
  decl = []; combinational = []; rsequential = []; wsequential = []
  port_spec = gen_port_spec(width,depth,ports,masking,mask_gran)
  decl.append('reg [%d:0] ram [%d:0];' % (width-1, depth-1))
  if ports == 2:
    rsequential.append('always @(posedge R0_clk) begin')
    wsequential.append('always @(posedge W0_clk) begin')
    decl.append('reg [%d:0] reg_R0_addr;' % (addr_width-1))
    rsequential.append('  if (R0_en) reg_R0_addr <= R0_addr;')
    combinational.append('assign R0_data = ram[reg_R0_addr];')
  else:
    rsequential.append('always @(posedge RW0_clk) begin')
    wsequential.append('always @(posedge RW0_clk) begin')
    decl.append('reg [%d:0] reg_RW0_addr;' % (addr_width-1))
    rsequential.append('  if (RW0_en && !RW0_wmode) reg_RW0_addr <= RW0_addr;')
    combinational.append('assign RW0_rdata = ram[reg_RW0_addr];')
  decl.append('`ifndef SYNTHESIS')
  decl.append('  integer initvar;')
  decl.append('  initial begin')
  decl.append('    #0.002;')
  decl.append('    for (initvar = 0; initvar < %d; initvar = initvar+1)' % depth)
  decl.append('      ram[initvar] = {%d {$random}};' % ((width-1)/32+1))
  if ports == 2:
    decl.append('    reg_R0_addr = {%d {$random}};' % ((addr_width-1)/32+1))
  else:
    decl.append('    reg_RW0_addr = {%d {$random}};' % ((addr_width-1)/32+1))
  decl.append('  end')
  decl.append('`endif')
  decl.append("integer i;")
  wsequential.append("  for (i = 0; i < %d; i=i+1) begin" % width)
  if ports == 2:
    if masking:
      decl.append("wire [%d:0] full_mask;" % (width-1))
      mask_expand_str = ','.join(map(lambda i:'{%d{W0_mask[%d]}}'%(mask_gran,i), reversed(range(0,width/mask_gran))))
      combinational.append("assign full_mask = {%s};" % mask_expand_str)
      wsequential.append("    if (W0_en && full_mask[i]) ram[W0_addr][i] <= W0_data[i];")
    else:
      wsequential.append("    if (W0_en) ram[W0_addr][i] <= W0_data[i];")
  else:
    if masking:
      decl.append("wire [%d:0] full_mask;" % (width-1))
      mask_expand_str = ','.join(map(lambda i:'{%d{RW0_wmask[%d]}}'%(mask_gran,i), reversed(range(0,width/mask_gran))))
      combinational.append("assign full_mask = {%s};" % mask_expand_str)
      wsequential.append("    if (RW0_en && RW0_wmode && full_mask[i]) ram[RW0_addr][i] <= RW0_wdata[i];")
    else:
      wsequential.append("    if (RW0_en && RW0_wmode) ram[RW0_addr][i] <= RW0_wdata[i];")
  wsequential.append("  end")
  s = '// vlsi_mem_gen: name=%s, depth=%d, width=%d, ports=%d, masking=%s%s\n' % \
    (name,depth,width,ports,str(masking),', mask_gran=%d'%mask_gran if masking else '')
  s += "module %s(\n\
  %s\n\
);\n\
  %s\n\
  %s\n\
  end\n\
  %s\n\
  end\n\
  %s\n\
endmodule\n\n" % (name, ',\n  '.join(port_spec), '\n  '.join(decl), '\n  '.join(wsequential), '\n  '.join(rsequential), '\n  '.join(combinational))
  f = open(outfile,'a')
  f.write(s)
  f.close()

def gen_port_spec(width,depth,ports,masked,mask_gran):
  addr_width = int(max(math.ceil(math.log(depth)/math.log(2)),1))
  port_spec = []
  decl = []; combinational = []; sequential = [];
  if ports==2:
    port_spec.append('input R0_clk')
    port_spec.append('input W0_clk')
    port_spec.append('input [%d:0] R0_addr' % (addr_width-1))
    port_spec.append('input R0_en')
    port_spec.append('output [%d:0] R0_data' % (width-1))
    port_spec.append('input [%d:0] W0_addr' % (addr_width-1))
    port_spec.append('input W0_en')
    if masked:
      port_spec.append('input [%d:0] W0_mask' % (width/mask_gran-1))
    port_spec.append('input [%d:0] W0_data' % (width-1))
  elif ports==1:
    port_spec.append('input RW0_clk')
    port_spec.append('input [%d:0] RW0_addr' % (addr_width-1))
    port_spec.append('input RW0_en')
    port_spec.append('input RW0_wmode')
    if masked:
      port_spec.append('input [%d:0] RW0_wmask' % (width/mask_gran-1))
    port_spec.append('input [%d:0] RW0_wdata' % (width-1))
    port_spec.append('output [%d:0] RW0_rdata' % (width-1))
  else:
    sys.exit('Error: A memory has a number of ports that is not 1 or 2:  %d' % ports)
  #port_spec.append('input init')
  #port_spec.append('input HS')
  #port_spec.append('input LS')
  return port_spec

def gen_report(mems,srams,reportfile):
  outstr =  '-----VLSI SRAM GENERATION REPORT-----\n\n---SUMMARY---\n\n'
  outstr += 'Total number of memories requested: %d\n' % len(mems)
  (n_match,n_multi,n_mismatch,n_ff,sram_bits,used_bits) = (0,0,0,0,0,0); 
  for name in sorted(mems.iterkeys()):
    mem = mems[name]
    if mem['mapped'] == 'FF': 
      n_ff += 1
    else:
      if mem['match_step'] == 1: n_match += 1
      elif (mem['match_step'] % 10) == 1: n_multi += 1
      elif (mem['match_step'] % 10) >= 2: n_mismatch += 1
      sram = srams[mem['mapped']]
      sram_bits += int(sram['width'])*int(sram['depth'])*mem['multi_d']*mem['multi_w']
      used_bits += int(mem['width'])*int(mem['depth'])
  outstr += 'Perfect matches: %d\n' % n_match
  outstr += 'Matches with multiplicity: %d\n' % n_multi
  outstr += 'Mismatches: %d\n' % n_mismatch
  outstr += 'FFs only: %d\n' % n_ff
  util = (100*float(used_bits)/float(sram_bits) if sram_bits > 0 else 0)
  outstr += 'Aggregate SRAM utilization: %.1f%% (assuming each memory is instantiated once)\n' % util
  outstr += '\n---MEMORY INSTANCES---\n'
  for name in sorted(mems.iterkeys()):
    mem = mems[name]
    outstr += '\nName: %s\n' % name
    outstr += 'Requested conf: Depth %d Width %d Ports %d Masking %s\n' % (mem['depth'],mem['width'],mem['ports'],mem['masking'])
    if 'mapped' in mem:
      if mem['mapped'] == 'FF':
        outstr += 'Mapped to: FFs only\n'
        if 'match_step' in mem:
          if mem['match_step'] == 0: outstr += 'Matched: N/A (tiny mems stay as FFs)\n'
          else: outstr += "Matched: No\n"
        outstr += 'Utilization: N/A\n'
      else:
        sram_name = mem['mapped']
        sram = srams[sram_name]
        sram_bits = int(sram['width'])*int(sram['depth'])*mem['multi_d']*mem['multi_w']
        used_bits = int(mem['width'])*int(mem['depth'])
        outstr += 'Mapped to: %s\n' % sram_name
        outstr += 'Mapped conf: Depth %d Width %d Ports %d Masking %s\n' % (sram['depth'],sram['width'],sram['ports'],sram['masking'])
        if mem['match_step'] == 1: outstr += 'Matched: Yes\n'
        elif (mem['match_step'] % 10) == 1: outstr += 'Matched: Yes (multiple)\n'
        else: outstr += 'Matched: No\n'
        if (mem['multi_d'] * mem['multi_w']) > 1: outstr += 'Multiplicity: %dx depth, %dx width\n' % (mem['multi_d'],mem['multi_w'])
        if mem['masking'] != sram['masking']: outstr += '\tSRAM mask hardcoded ON\n'
        if mem['ports'] != sram['ports']: outstr += '\tSingle-port memory mapped to dual-port SRAM\n'
        outstr += 'Mapped at step: %d\n' % mem['match_step']
        outstr += 'Utilization: %.1f%%\n' % (100*float(used_bits)/float(sram_bits))
    else:
      sys.exit('Error: vlsi_mem_gen has run, but not all memories were mapped!  %s' % name)
  outstr += '\n---REQUEST THESE MISSING SRAM CONFIGURATIONS---\n\n'
  for name in sorted(mems.iterkeys()):
    request_mem = False
    mem = mems[name]
    if 'match_step' in mem:
      if mem['match_step'] % 10 >= 2: 
        sram_name = mem['mapped']
        sram = srams[sram_name]
        sram_bits = int(sram['width'])*int(sram['depth'])*mem['multi_d']*mem['multi_w']
        used_bits = int(mem['width'])*int(mem['depth'])
        if float(used_bits)/float(sram_bits) < 0.95: request_mem = True
      if request_mem or mem['match_step'] == 1000:
        outstr += '%s: Depth %d Width %d Ports %d Masking %s\n' % (name,mem['depth'],mem['width'],mem['ports'],mem['masking'])
  f = open(reportfile,'w')
  f.write(outstr)

# see for example /tools/tstech16/CLN16FFC/TSMCHOME/sram/Documentation/documents/tsn16ffcllspsram_20131200_100a/DB_TSN16FFCLLSPSRAM_20131200_100A.pdf
def get_wtsel(ports,mux,width,vt):
  if ports==2:
    if vt == 'ulvt':
      return "2'b01"
    else:
      return "2'b00"
  elif vt=='svt':
    if mux==16 and width<1024:
      return "2'b01"
    else:
      return "2'b00"
  elif vt=='lvt':
    if (width<64*mux):
      return "2'b01"
    else:
      return "2'b00"
  else: #vt=='ulvt'
    if (width<256*mux):
      return "2'b01"
    else:
      return "2'b00"
    

if __name__ == '__main__':
  main()
